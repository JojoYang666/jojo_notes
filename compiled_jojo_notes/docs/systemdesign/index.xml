<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://jojoyang.site/jojo_notes/docs/systemdesign/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://jojoyang.site/jojo_notes/docs/systemdesign/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://jojoyang.site/jojo_notes/docs/systemdesign/data-models-and-query-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jojoyang.site/jojo_notes/docs/systemdesign/data-models-and-query-languages/</guid>
      <description>Relational Model # Relational databases: transaction processing or batch processing Goal: hide the implementation detail behind a cleaner interface foreign key for join Pros: fit for joins - many to one and many to many relationships Schema-on-write - schema explicit and db ebsures data conforms to it Migration needed whe schema changed migrate at one time Set null for the new schema and fill/update it at the read time Document Model(No sql) # Greater scalability A more dynamic and experssive data mode document rederence for join Schema-on-read: the implicit data structure * only interpreted when data is read Application code to handle the implict schema changes.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://jojoyang.site/jojo_notes/docs/systemdesign/storage-and-retrieval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jojoyang.site/jojo_notes/docs/systemdesign/storage-and-retrieval/</guid>
      <description>Data Structures that Power Your Database # Index: To keep some additional metadata on the side, which acts as a signpost and help to locate the additional metadata on the side. Trade off in the storage systems: well-chosen indexes speed up read queries but every index slows down writes Write &amp;ndash;&amp;gt; append on the file Hash Indexes # In memory hash map(e.g. bitcask) # Key is mapped to a byte offset in the data file High performance on both write and read &amp;ndash;&amp;gt; keys fit in the available RAM Fit for: value for each key is updated frequently Avioid running out of disk space if only append to a file for writing operation(insert &amp;amp; update) Break the log into segments of a certain size by closing a segment file when it reaches a certain size Perform compaction on the segments in a background thread Possible issues on implementaion of the segments and compaction # File format</description>
    </item>
    
  </channel>
</rss>
